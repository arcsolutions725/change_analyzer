<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MEXC Change Analyzer</title>
  <style>
    :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa0a6; --green:#17c964; --red:#ef4444; --card:#141821; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
    header { padding: 12px 16px; border-bottom: 1px solid #1f2430; display: flex; gap: 16px; align-items: center; }
    header h1 { font-size: 16px; margin: 0; }
    .controls { display: flex; gap: 12px; align-items: center; color: var(--muted); }
    .controls label { font-size: 12px; }
    .container { padding: 16px; }
    table { width: 100%; border-collapse: collapse; background: var(--card); }
    thead th { position: sticky; top: 0; background: #171b24; font-weight: 600; color: var(--muted); font-size: 12px; text-align: left; padding: 10px; border-bottom: 1px solid #1f2430; }
    tbody td { padding: 10px; border-bottom: 1px solid #1f2430; font-size: 13px; }
    td.num { text-align: right; font-feature-settings: "tnum" 1, "lnum" 1; }
    .chip { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
    .pos { color: var(--green); }
    .neg { color: var(--red); }
    .muted { color: var(--muted); }
    .row { transition: background 0.2s ease; }
    .row.flash { background: rgba(23, 201, 100, 0.08); }
    .nowrap { white-space: nowrap; }
    .small { font-size: 12px; }
    .sticky-wrap { overflow: auto; max-height: calc(100vh - 80px); }
  </style>
</head>
<body>
  <header>
    <h1>MEXC Spot Mini Tickers</h1>
    <div class="controls">
      <label>Quote filter:
        <select id="quoteFilter">
          <option value="ALL">ALL</option>
          <option value="USDT">USDT</option>
          <option value="USDC">USDC</option>
          <option value="BTC">BTC</option>
          <option value="ETH">ETH</option>
        </select>
      </label>
      <label>Poll interval:
        <select id="interval">
          <option value="3000">3s</option>
          <option value="5000">5s</option>
          <option value="10000">10s</option>
        </select>
      </label>
      <span id="status" class="muted small">Idle</span>
    </div>
  </header>
  <div class="container">
    <div class="sticky-wrap">
      <table id="table">
        <thead id="thead"></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>
  <script>
    const API = '/api/ticker24'
    const WS_PATH = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/stream'
    const thead = document.getElementById('thead')
    const tbody = document.getElementById('tbody')
    const statusEl = document.getElementById('status')
    const quoteFilterEl = document.getElementById('quoteFilter')
    const intervalEl = document.getElementById('interval')

    let timer = null
    let tick = 0
    const maxHistory = 12
    const state = new Map()

    function fmtNum(v, digits = 6) {
      if (v == null || v === '') return ''
      const n = Number(v)
      if (Number.isNaN(n)) return v
      if (Math.abs(n) >= 1) return n.toLocaleString(undefined, { maximumFractionDigits: 2 })
      return n.toLocaleString(undefined, { maximumFractionDigits: digits })
    }

    function fmtPct(p) {
      const n = Number(p)
      if (Number.isNaN(n)) return ''
      return (n * 100).toFixed(2) + '%'
    }

    function pairWithSlash(symbol) {
      const knownQuotes = ['USDT','USDC','BTC','ETH','MX','BNB']
      for (const q of knownQuotes) {
        if (symbol.endsWith(q)) return symbol.slice(0, -q.length) + '/' + q
      }
      return symbol
    }

    function buildHeader() {
      const cols = ['Pair','Price','Change %']
      for (let i = Math.max(0, tick - (maxHistory - 1)); i <= tick; i++) cols.push('t' + i)
      thead.innerHTML = '<tr>' + cols.map(c => `<th class="nowrap">${c}</th>`).join('') + '</tr>'
    }

    async function fetchTickers() {
      const start = Date.now()
      statusEl.textContent = 'Fetching...'
      try {
        const res = await fetch(API)
        const data = await res.json()
        const quoteFilter = quoteFilterEl.value
        const items = Array.isArray(data) ? data : [data]
        const filtered = items.filter(x => {
          if (quoteFilter === 'ALL') return true
          return x.symbol.endsWith(quoteFilter)
        })
        filtered.forEach(x => {
          const symbol = x.symbol
          const lastPrice = x.lastPrice
          const pct = x.priceChangePercent
          const amount = x.volume || x.quoteVolume || ''
          let row = state.get(symbol)
          if (!row) {
            row = { symbol, lastPrice: null, pct: null, amount: null, history: [] }
            state.set(symbol, row)
          }
          row.lastPrice = lastPrice
          row.pct = pct
          row.amount = amount
          row.history.push(pct)
          if (row.history.length > maxHistory) row.history.shift()
        })
        tick++
        render()
        const ms = Date.now() - start
        statusEl.textContent = 'Updated ' + new Date().toLocaleTimeString() + ' â€¢ ' + ms + 'ms'
      } catch (e) {
        statusEl.textContent = 'Error'
      }
    }

    function render() {
      buildHeader()
      const rows = Array.from(state.values())
      rows.sort((a,b) => Number(b.pct) - Number(a.pct))
      const startIdx = Math.max(0, aTickStart())
      const endIdx = startIdx + Math.min(maxHistory, tick + 1 - startIdx)
      const html = rows.map(r => {
        const cls = Number(r.pct) >= 0 ? 'pos' : 'neg'
        const pair = pairWithSlash(r.symbol)
        const chips = r.history.slice(startIdx, endIdx).map(v => {
          const c = Number(v) >= 0 ? 'pos' : 'neg'
          return `<span class="chip ${c}">${fmtPct(v)}</span>`
        })
        return `<tr class="row"><td>${pair}</td><td class="num">${fmtNum(r.lastPrice)}</td><td class="num ${cls}">${fmtPct(r.pct)}</td>${histCols(chips)}</tr>`
      }).join('')
      tbody.innerHTML = html
    }

    function aTickStart() { return Math.max(0, tick - (maxHistory - 1)) }
    function histCols(chips) {
      if (!chips || chips.length === 0) return ''
      return chips.map(p => `<td>${p}</td>`).join('')
    }

    function startPolling() {
      if (timer) clearInterval(timer)
      fetchTickers()
      timer = setInterval(fetchTickers, Number(intervalEl.value))
    }

    function startWebSocket() {
      try {
        const ws = new WebSocket(WS_PATH)
        ws.onopen = () => { statusEl.textContent = 'Streaming' }
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data)
            if (msg.type === 'ticker24') {
              const data = msg.data
              const quoteFilter = quoteFilterEl.value
              const items = Array.isArray(data) ? data : [data]
              const filtered = items.filter(x => quoteFilter === 'ALL' ? true : x.symbol.endsWith(quoteFilter))
              filtered.forEach(x => {
                const symbol = x.symbol
                const lastPrice = x.lastPrice
                const pct = x.priceChangePercent
                const amount = x.volume || x.quoteVolume || ''
                let row = state.get(symbol)
                if (!row) {
                  row = { symbol, lastPrice: null, pct: null, amount: null, history: [] }
                  state.set(symbol, row)
                }
                row.lastPrice = lastPrice
                row.pct = pct
                row.amount = amount
                row.history.push(pct)
                if (row.history.length > maxHistory) row.history.shift()
              })
              tick++
              render()
            }
          } catch {}
        }
        ws.onclose = () => { statusEl.textContent = 'Disconnected'; startPolling() }
        ws.onerror = () => { statusEl.textContent = 'WS Error'; startPolling() }
      } catch {
        startPolling()
      }
    }

    quoteFilterEl.addEventListener('change', () => { state.clear(); tick = 0; startPolling() })
    intervalEl.addEventListener('change', () => { startPolling() })

    startWebSocket()
  </script>
</body>
</html>