<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MEXC Change Analyzer</title>
  <style>
    :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa0a6; --green:#17c964; --red:#ff0000; --card:#141821; --pair-w:160px; --price-w:120px; --cell-w:110px; --no-w:60px; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
    header { padding: 12px 16px; border-bottom: 1px solid #1f2430; display: flex; gap: 16px; align-items: center; }
    header h1 { font-size: 16px; margin: 0; }
    .controls { display: flex; gap: 12px; align-items: center; color: var(--muted); }
    .controls label { font-size: 12px; }
    .container { padding: 16px; }
    table { border-collapse: collapse; background: var(--card); table-layout: fixed; }
    thead th { position: sticky; top: 0; background: #171b24; font-weight: 600; color: var(--muted); font-size: 12px; text-align: left; padding: 10px; border-bottom: 1px solid #1f2430; }
    tbody td { padding: 10px; border-bottom: 1px solid #1f2430; font-size: 13px; }
    td.num { text-align: right; font-feature-settings: "tnum" 1, "lnum" 1; }
    .chip { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
    .pos { color: var(--green); text-align: left !important; }
    .neg { color: var(--red); }
    .num.neg { color: var(--red); text-align: left !important; }
    .muted { color: var(--muted); }
    .new { color: #facc15; }
    .arrow-up { color: #facc15; }
    .arrow-down { color: var(--red); }
    .arrow-flat { color: var(--muted); }
    .toast-root { position: fixed; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
    .toast { background: #171b24; color: #facc15; border: 1px solid #2a3140; padding: 8px 12px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.25); transition: all 0.3s ease; }
    .toast.hide { opacity: 0; transform: translateY(-4px); }
    .toast-close { background: transparent; border: 0; color: #facc15; margin-left: 10px; cursor: pointer; font-size: 14px; }
    .copyable { cursor: pointer; }
    .row { transition: background 0.2s ease; }
    .row.flash { background: rgba(23, 201, 100, 0.08); }
    .row.selected { background: rgba(47, 128, 237, 0.18); }
    .row-c10 { background: hsla(120, 70%, 45%, 0.3); }
    .row-c11 { background: hsla(132, 70%, 45%, 0.3); }
    .row-c12 { background: hsla(144, 70%, 45%, 0.3); }
    .row-c13 { background: hsla(156, 70%, 45%, 0.3); }
    .row-c14 { background: hsla(168, 70%, 45%, 0.3); }
    .row-c15 { background: hsla(180, 70%, 45%, 0.3); }
    .row-c16 { background: hsla(192, 70%, 45%, 0.3); }
    .row-c17 { background: hsla(204, 70%, 45%, 0.3); }
    .row-c18 { background: hsla(216, 70%, 45%, 0.3); }
    .row-c19 { background: hsla(228, 70%, 45%, 0.3); }
    .row-c20 { background: hsla(240, 70%, 45%, 0.3); }
    .row-c21 { background: hsla(252, 70%, 45%, 0.3); }
    .row-c22 { background: hsla(264, 70%, 45%, 0.3); }
    .row-c23 { background: hsla(276, 70%, 45%, 0.3); }
    .row-c24 { background: hsla(288, 70%, 45%, 0.3); }
    .row-c25 { background: hsla(300, 70%, 50%, 0.3); }
    .row-c26 { background: hsla(312, 70%, 50%, 0.3); }
    .row-c27 { background: hsla(324, 70%, 50%, 0.3); }
    .row-c28 { background: hsla(336, 70%, 50%, 0.3); }
    .row-c29 { background: hsla(348, 70%, 50%, 0.3); }
    .nowrap { white-space: nowrap; }
    .small { font-size: 12px; }
    .sticky-wrap { overflow: scroll; max-height: calc(100vh - 80px); }
    .layout { display: flex; gap: 8px; }
    .left { flex: 0 0 auto; }
    .right { flex: 1 1 auto;}
    .col-pair { width: var(--pair-w); min-width: var(--pair-w); }
    .col-price { width: var(--price-w); min-width: var(--price-w); }
    .col-no { width: var(--no-w); min-width: var(--no-w); }
    .cell { width: var(--cell-w); min-width: var(--cell-w); }
  </style>
</head>
<body>
  <header>
    <h1>MEXC Spot Mini Tickers</h1>
    <div class="controls">
      <label>Poll interval:
        <select id="interval">
          <option value="10000">10s</option>
          <option value="20000">20s</option>
          <option value="30000">30s</option>
        </select>
      </label>
      <span id="status" class="muted small">Idle</span>
    </div>
  </header>
  <div class="toast-root" id="toastRoot"></div>
  <div class="container">
    <div id="newTokensBar" class="small" style="margin:8px 0 12px 0;"></div>
    <div class="sticky-wrap">
      <div class="layout">
        <div class="left">
          <table id="tableLeft">
            <thead id="theadLeft"></thead>
            <tbody id="tbodyLeft"></tbody>
          </table>
        </div>
        <div class="right">
          <table id="tableRight">
            <thead id="theadRight"></thead>
            <tbody id="tbodyRight"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  <script>
    const API = '/api/ticker24'
    const WS_PATH = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/stream'
    const theadLeft = document.getElementById('theadLeft')
    const tbodyLeft = document.getElementById('tbodyLeft')
    const theadRight = document.getElementById('theadRight')
    const tbodyRight = document.getElementById('tbodyRight')
    const statusEl = document.getElementById('status')
    const intervalEl = document.getElementById('interval')

    let timer = null
    let tick = 0
    const maxHistory = 30
    const maxPriceHistory = 200
    const trendWindow = 10
    const state = new Map()
    let selectedSymbol = null
    const alertedNew = new Set()
    const newBarEl = document.getElementById('newTokensBar')
    const toastRoot = document.getElementById('toastRoot')
    let nextColor = 0

    function fmtNum(v, digits = 6) {
      if (v == null || v === '') return ''
      const n = Number(v)
      if (Number.isNaN(n)) return v
      if (Math.abs(n) >= 1) return n.toLocaleString(undefined, { maximumFractionDigits: 2 })
      return n.toLocaleString(undefined, { maximumFractionDigits: digits })
    }

    function fmtPct(p) {
      const n = Number(p)
      if (Number.isNaN(n)) return ''
      return (n * 100).toFixed(2) + '%'
    }

    function fmtSpeed(s) {
      const n = Number(s)
      if (Number.isNaN(n)) return ''
      return n.toFixed(2) + '%/m'
    }

    function computeTrend(pts) {
      if (!pts || pts.length < trendWindow) return 0
      const slice = pts.slice(pts.length - trendWindow)
      const xs = slice.map((pt) => (pt.ts - slice[0].ts) / 60000)
      const ys = slice.map((pt) => Math.log(Math.max(1e-12, pt.p)))
      let mx = 0, my = 0
      for (let i = 0; i < xs.length; i++) { mx += xs[i]; my += ys[i] }
      mx /= xs.length; my /= ys.length
      let num = 0, den = 0
      for (let i = 0; i < xs.length; i++) { const dx = xs[i] - mx; num += dx * (ys[i] - my); den += dx * dx }
      if (den === 0) return 0
      const slopePerMin = num / den
      return slopePerMin * 100
    }

    function notifyNew(symbol) {
      if (alertedNew.has(symbol)) return
      const text = pairWithSlash(symbol)
      console.log("new token", text)
      statusEl.textContent = 'New ' + text + ' copied'
      alertedNew.add(symbol)
      renderNewBar()
      showToast('New token: ' + text + ' copied')
    }

    function renderNewBar() {
      if (!newBarEl) return
      if (alertedNew.size === 0) { newBarEl.textContent = ''; return }
      const items = Array.from(alertedNew)
      const chips = items.map(s => `<span class="chip new">${pairWithSlash(s)}</span>`).join(' ')
      newBarEl.innerHTML = `<span class="new">New tokens:</span> ${chips}`
    }

    function showToast(text) {
      if (!toastRoot) return
      const el = document.createElement('div')
      el.className = 'toast'
      const span = document.createElement('span')
      span.textContent = text
      const btn = document.createElement('button')
      btn.className = 'toast-close'
      btn.textContent = '×'
      btn.addEventListener('click', () => { try { toastRoot.removeChild(el) } catch {} })
      el.appendChild(span)
      el.appendChild(btn)
      toastRoot.appendChild(el)
    }

    function pairWithSlash(symbol) {
      const knownQuotes = ['USDT','USDC','BTC','ETH','MX','BNB']
      for (const q of knownQuotes) {
        if (symbol.endsWith(q)) return symbol.slice(0, -q.length) + '/' + q
      }
      return symbol
    }

    function pairUrl(symbol) {
      const knownQuotes = ['USDT','USDC','BTC','ETH','MX','BNB']
      for (const q of knownQuotes) {
        if (symbol.endsWith(q)) {
          const base = symbol.slice(0, -q.length)
          return 'https://www.mexc.com/exchange/' + base + '_' + q + '?_from=search_spot_trade'
        }
      }
      return 'https://www.mexc.com/exchange/' + symbol + '?_from=search_spot_trade'
    }

    function buildHeaders() {
      theadLeft.innerHTML = '<tr>' + ['No','Pair','Price'].map((c,i) => {
        const cls = i===0?'col-no':(i===1?'col-pair':'col-price')
        return `<th class="nowrap ${cls}">${c}</th>`
      }).join('') + '</tr>'
      const labels = ['Trend(10)','Change %']
      const histCount = Math.min(maxHistory, tick)
      for (let i = histCount; i >= 1; i--) labels.push('t' + i)
      theadRight.innerHTML = '<tr>' + labels.map(c => `<th class="nowrap cell">${c}</th>`).join('') + '</tr>'
    }

    async function fetchTickers() {
      const start = Date.now()
      statusEl.textContent = 'Fetching...'
      try {
        const res = await fetch(API)
        const data = await res.json()
        const items = Array.isArray(data) ? data : [data]
        const filtered = items.filter(x => x.symbol.endsWith('USDT'))
        filtered.forEach(x => {
          const symbol = x.symbol
          const lastPrice = x.lastPrice
          const pct = x.priceChangePercent
          const amount = x.volume || x.quoteVolume || ''
          let row = state.get(symbol)
          if (!row) {
            row = { symbol, lastPrice: null, pct: null, amount: null, history: [], priceHistory: [], trend10: 0, prevTrend10: null, colorIdx: (nextColor++ % 30) }
            state.set(symbol, row)
            if (tick >= trendWindow) notifyNew(symbol)
          }
          const now = Date.now()
          row.priceHistory.push({ p: Number(lastPrice), ts: now })
          if (row.priceHistory.length > maxPriceHistory) row.priceHistory.shift()
          const prevT = row.trend10
          row.trend10 = computeTrend(row.priceHistory)
          row.prevTrend10 = prevT
          row.lastPrice = lastPrice
          row.pct = pct
          row.amount = amount
          row.history.push(pct)
          if (row.history.length > maxHistory) row.history.shift()
        })
        tick++
        render()
        const ms = Date.now() - start
        statusEl.textContent = 'Updated ' + new Date().toLocaleTimeString() + ' • ' + ms + 'ms'
      } catch (e) {
        statusEl.textContent = 'Error'
      }
    }

    function render() {
      buildHeaders()
      const rows = Array.from(state.values())
      rows.sort((a,b) => {
        const al = (a.priceHistory && a.priceHistory.length) ? a.priceHistory.length : 0
        const bl = (b.priceHistory && b.priceHistory.length) ? b.priceHistory.length : 0
        const aNew = (tick >= trendWindow) && (al < trendWindow)
        const bNew = (tick >= trendWindow) && (bl < trendWindow)
        if (aNew && !bNew) return -1
        if (bNew && !aNew) return 1
        return Number(b.trend10 || 0) - Number(a.trend10 || 0)
      })
      const top = rows.slice(0, 30)
      const historyCols = Math.min(maxHistory, tick)
      const leftHtml = top.map((r,i) => {
        const cls = Number(r.pct) >= 0 ? 'pos' : 'neg'
        const pair = pairWithSlash(r.symbol)
        return `<tr class="row" data-symbol="${r.symbol}"><td class="num col-no">${i+1}</td><td class="col-pair copyable" data-pair="${pair}" title="Click to copy">${pair}</td><td class="num col-price">${fmtNum(r.lastPrice)}</td></tr>`
      }).join('')
      const rightHtml = top.map((r,i) => {
        const cls = Number(r.pct) >= 0 ? 'pos' : 'neg'
        const isNew = (tick >= trendWindow) && !(r.priceHistory && r.priceHistory.length >= trendWindow)
        const scls = isNew ? 'new' : (Number(r.trend10) >= 0 ? 'pos' : 'neg')
        const cells = []
        for (let i = 0; i < historyCols; i++) {
          const idx = r.history.length - 1 - i
          const v = idx >= 0 ? r.history[idx] : null
          let c = 'muted'
          let text = ''
          if (v != null) {
            const n = Number(v)
            c = Number.isNaN(n) ? 'muted' : (n >= 0 ? 'pos' : 'neg')
            text = fmtPct(v)
          }
          cells.push(`<td class="cell ${c}">${text}</td>`)
        }
        const arrowHtml = (() => {
          if (isNew || r.prevTrend10 == null) return ''
          const cur = Number(r.trend10)
          const prev = Number(r.prevTrend10)
          if (cur > prev) return '<span class="arrow-up">↑</span>'
          if (cur < prev) return '<span class="arrow-down">↓</span>'
          return '<span class="arrow-flat">→</span>'
        })()
        const trendText = isNew ? 'new token' : `${arrowHtml} ${fmtSpeed(r.trend10)}`
        return `<tr class="row" data-symbol="${r.symbol}"><td class="num ${scls} cell">${trendText}</td><td class="num ${cls} cell">${fmtPct(r.pct)}</td>${cells.join('')}</tr>`
      }).join('')
      tbodyLeft.innerHTML = leftHtml
      tbodyRight.innerHTML = rightHtml
      if (selectedSymbol) setActive(selectedSymbol)
    }

    function aTickStart() { return Math.max(0, tick - (maxHistory - 1)) }
    function histCols(chips) {
      if (!chips || chips.length === 0) return ''
      return chips.map(p => `<td class="cell">${p}</td>`).join('')
    }

    function startPolling() {
      if (timer) clearInterval(timer)
      fetchTickers()
      timer = setInterval(fetchTickers, Number(intervalEl.value))
    }

    function startWebSocket() {
      try {
        const ws = new WebSocket(WS_PATH)
        ws.onopen = () => { statusEl.textContent = 'Streaming' }
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data)
            if (msg.type === 'miniTickers') {
              const data = msg.data
              const items = Array.isArray(data) ? data : [data]
              const filtered = items.filter(x => x.symbol.endsWith('USDT'))
              filtered.forEach(x => {
                const symbol = x.symbol
                const lastPrice = x.price
                const pct = (x.zonedRate ?? x.rate)
                const amount = x.quantity || x.volume || ''
                let row = state.get(symbol)
                if (!row) {
                  row = { symbol, lastPrice: null, pct: null, amount: null, history: [], priceHistory: [], trend10: 0, prevTrend10: null }
                  state.set(symbol, row)
                  if (tick >= trendWindow) notifyNew(symbol)
                }
                const now = Date.now()
                row.priceHistory.push({ p: Number(lastPrice), ts: now })
                if (row.priceHistory.length > maxPriceHistory) row.priceHistory.shift()
                const prevT = row.trend10
                row.trend10 = computeTrend(row.priceHistory)
                row.prevTrend10 = prevT
                row.lastPrice = lastPrice
                row.pct = pct
                row.amount = amount
                row.history.push(pct)
                if (row.history.length > maxHistory) row.history.shift()
              })
              tick++
              render()
            }
          } catch {}
        }
        ws.onclose = () => { statusEl.textContent = 'Disconnected'; startPolling() }
        ws.onerror = () => { statusEl.textContent = 'WS Error'; startPolling() }
      } catch {
        startPolling()
      }
    }

    function setActive(symbol) {
      selectedSymbol = symbol
      document.querySelectorAll('tr.row.selected').forEach(el => el.classList.remove('selected'))
      document.querySelectorAll(`tr.row[data-symbol="${symbol}"]`).forEach(el => el.classList.add('selected'))
    }

    function onRowClick(e) {
      const tr = e.target.closest('tr.row')
      if (!tr) return
      const symbol = tr.getAttribute('data-symbol')
      if (!symbol) return
      setActive(symbol)
      const text = pairUrl(symbol)
      try {
        navigator.clipboard && navigator.clipboard.writeText(text)
        statusEl.textContent = 'Copied ' + text
      } catch {}
    }

    tbodyLeft.addEventListener('click', onRowClick)
    tbodyRight.addEventListener('click', onRowClick)

    intervalEl.addEventListener('change', () => { startPolling() })

    startWebSocket()
    startPolling()
  </script>
</body>
</html>