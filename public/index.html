<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MEXC Change Analyzer</title>
  <style>
    :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa0a6; --green:#17c964; --red:#ff0000; --card:#141821; --pair-w:120px; --price-w:120px; --cell-w:110px; --no-w:60px; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
    header { padding: 12px 16px; border-bottom: 1px solid #1f2430; display: flex; gap: 16px; align-items: center; }
    header h1 { font-size: 16px; margin: 0; }
    .controls { display: flex; gap: 12px; align-items: center; color: var(--muted); }
    .controls label { font-size: 12px; }
    .segmented { display: inline-flex; background: #171b24; border-radius: 999px; padding: 2px; border: 1px solid #2a3140; }
    .segmented .seg-option { border: 0; background: transparent; color: var(--muted); padding: 6px 12px; border-radius: 999px; cursor: pointer; font-size: 12px; }
    .segmented .seg-option.active { background: var(--green); color: #0f1115; }
    .container { padding: 16px; }
    table { border-collapse: collapse; background: var(--card); table-layout: fixed; }
    thead th { position: sticky; top: 0; background: #171b24; font-weight: 600; color: var(--muted); font-size: 12px; text-align: left; padding: 10px; border-bottom: 1px solid #1f2430; }
    tbody td { padding: 10px; border-bottom: 1px solid #1f2430; font-size: 13px; }
    td.num { text-align: right; font-feature-settings: "tnum" 1, "lnum" 1; }
    .chip { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
    .pos { color: var(--green); text-align: left !important; }
    .neg { color: var(--red); }
    .num.neg { color: var(--red); text-align: left !important; }
    .muted { color: var(--muted); }
    .new { color: #facc15; }
    .arrow-up { color: #facc15; }
    .arrow-down { color: var(--red); }
    .arrow-flat { color: var(--muted); }
    .toast-root { position: fixed; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
    .toast { background: #171b24; color: #facc15; border: 1px solid #2a3140; padding: 8px 12px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.25); transition: all 0.3s ease; }
    .toast.hide { opacity: 0; transform: translateY(-4px); }
    .toast-close { background: transparent; border: 0; color: #facc15; margin-left: 10px; cursor: pointer; font-size: 14px; }
    .copyable { cursor: pointer; }
    .row { transition: background 0.2s ease; }
    .row.flash { background: rgba(23, 201, 100, 0.08); }
    .row.selected { background: rgba(47, 128, 237, 0.18); }
    .row-c10 { background: hsla(120, 70%, 45%, 0.3); }
    .row-c11 { background: hsla(132, 70%, 45%, 0.3); }
    .row-c12 { background: hsla(144, 70%, 45%, 0.3); }
    .row-c13 { background: hsla(156, 70%, 45%, 0.3); }
    .row-c14 { background: hsla(168, 70%, 45%, 0.3); }
    .row-c15 { background: hsla(180, 70%, 45%, 0.3); }
    .row-c16 { background: hsla(192, 70%, 45%, 0.3); }
    .row-c17 { background: hsla(204, 70%, 45%, 0.3); }
    .row-c18 { background: hsla(216, 70%, 45%, 0.3); }
    .row-c19 { background: hsla(228, 70%, 45%, 0.3); }
    .row-c20 { background: hsla(240, 70%, 45%, 0.3); }
    .row-c21 { background: hsla(252, 70%, 45%, 0.3); }
    .row-c22 { background: hsla(264, 70%, 45%, 0.3); }
    .row-c23 { background: hsla(276, 70%, 45%, 0.3); }
    .row-c24 { background: hsla(288, 70%, 45%, 0.3); }
    .row-c25 { background: hsla(300, 70%, 50%, 0.3); }
    .row-c26 { background: hsla(312, 70%, 50%, 0.3); }
    .row-c27 { background: hsla(324, 70%, 50%, 0.3); }
    .row-c28 { background: hsla(336, 70%, 50%, 0.3); }
    .row-c29 { background: hsla(348, 70%, 50%, 0.3); }
    .nowrap { white-space: nowrap; }
    .small { font-size: 12px; }
    .sticky-wrap { max-height: calc(100vh - 80px); }
    .sections-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
    .section { display: flex; flex-direction: column;}
    .layout { display: flex; gap: 8px; }
    .left { flex: 0 0 auto; }
    .right { flex: 1 1 auto;}
    .col-pair { width: var(--pair-w); min-width: var(--pair-w); }
    .col-price { width: var(--price-w); min-width: var(--price-w); }
    .col-no { width: var(--no-w); min-width: var(--no-w); }
    .cell { width: var(--cell-w); min-width: var(--cell-w); }
    .section-title { font-size: 12px; color: var(--muted); margin: 8px 0 6px 0; }
  </style>
</head>
<body>
  <header>
    <h1>MEXC Future Mini Tickers</h1>
    <div class="controls">
      <div class="segmented" id="orderSwitch">
        <button class="seg-option active" data-mode="streak">Up-streak</button>
        <button class="seg-option" data-mode="downstreak">Down-streak</button>
        <button class="seg-option" data-mode="upcount">Up-count</button>
        <button class="seg-option" data-mode="downcount">Down-count</button>
        <button class="seg-option" data-mode="mixed">Mixed</button>
      </div>
      <span id="status" class="muted small">Idle</span>
    </div>
  </header>
  <div class="toast-root" id="toastRoot"></div>
  <div id="lockScreen" style="position:fixed;inset:0;background:#0f1115;display:flex;align-items:center;justify-content:center;z-index:9998;">
    <div style="background:#171b24;border:1px solid #2a3140;border-radius:12px;padding:20px;min-width:280px;display:flex;flex-direction:column;gap:10px;">
      <div class="small muted">Enter password to unlock</div>
      <input id="pwdInput" type="password" placeholder="Password" style="padding:8px 10px;border-radius:8px;border:1px solid #2a3140;background:#141821;color:#e6e6e6;outline:none;" />
      <button id="unlockBtn" style="padding:8px 10px;border-radius:8px;border:1px solid #2a3140;background:#17c964;color:#0f1115;cursor:pointer;">Unlock</button>
      <div id="loginError" class="small" style="color:#ff0000;display:none;">Invalid password</div>
    </div>
  </div>
  <div class="container">
    <div id="newTokensBar" class="small" style="margin:8px 0 12px 0;"></div>
    <div class="sticky-wrap">
      <div class="sections-grid">
        <div class="section">
          <div class="section-title">5s</div>
          <div class="layout">
            <div class="left">
              <table id="tableLeft1">
                <thead id="theadLeft1"></thead>
                <tbody id="tbodyLeft1"></tbody>
              </table>
            </div>
            <div class="right">
              <table id="tableRight1">
                <thead id="theadRight1"></thead>
                <tbody id="tbodyRight1"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const API = '/api/ticker24'
    const WS_PATH = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/stream'
    const sections = [
      { id: 1, intervalMs: 5000, theadLeft: document.getElementById('theadLeft1'), tbodyLeft: document.getElementById('tbodyLeft1'), theadRight: document.getElementById('theadRight1'), tbodyRight: document.getElementById('tbodyRight1'), state: new Map(), tick: 0, timer: null }
    ]
    const statusEl = document.getElementById('status')
    const orderSwitch = document.getElementById('orderSwitch')
    let orderMode = 'streak'

    let timer = null
    let tick = 0
    const maxHistory = 30
    const maxPriceHistory = 200
    const trendWindow = 10
    const maxTrendHistory = 10
    const priceCols = 20
    const pointsPerMinute = 12
    const state = new Map()
    let selectedSymbol = null
    const alertedNew = new Set()
    const newBarEl = document.getElementById('newTokensBar')
    const toastRoot = document.getElementById('toastRoot')
    let nextColor = 0
    const allowedFutures = new Set()
    let futuresReady = false
    let authToken = (typeof localStorage !== 'undefined' ? localStorage.getItem('authToken') : '') || ''
    const lockScreen = document.getElementById('lockScreen')
    const pwdInput = document.getElementById('pwdInput')
    const unlockBtn = document.getElementById('unlockBtn')
    const loginError = document.getElementById('loginError')
    const hydratedSymbols = new Set()

    function fmtNum(v, digits = 6) {
      if (v == null || v === '') return ''
      const n = Number(v)
      if (Number.isNaN(n)) return v
      if (Math.abs(n) >= 1) return n.toLocaleString(undefined, { maximumFractionDigits: 2 })
      return n.toLocaleString(undefined, { maximumFractionDigits: digits })
    }

    function fmtPct(p) {
      const n = Number(p)
      if (Number.isNaN(n)) return ''
      return (n * 100).toFixed(2) + '%'
    }

    function fmtSpeed(s) {
      const n = Number(s)
      if (Number.isNaN(n)) return ''
      return n.toFixed(2) + '%/m'
    }

    function upStreak(ph) {
      if (!ph || ph.length < 2) return 0
      let cnt = 0
      for (let i = ph.length - 1; i > 0 && cnt < priceCols; i--) {
        const cur = Number(ph[i].p)
        const prev = Number(ph[i-1].p)
        if (Number.isNaN(cur) || Number.isNaN(prev)) break
        if (cur > prev) cnt++
        else break
      }
      return cnt
    }

    function downStreak(ph) {
      if (!ph || ph.length < 2) return 0
      let cnt = 0
      for (let i = ph.length - 1; i > 0 && cnt < priceCols; i--) {
        const cur = Number(ph[i].p)
        const prev = Number(ph[i-1].p)
        if (Number.isNaN(cur) || Number.isNaN(prev)) break
        if (cur < prev) cnt++
        else break
      }
      return cnt
    }

    function upCount(ph) {
      if (!ph || ph.length < 2) return 0
      let cnt = 0
      let steps = 0
      for (let i = ph.length - 1; i > 0 && steps < priceCols; i--, steps++) {
        const cur = Number(ph[i].p)
        const prev = Number(ph[i-1].p)
        if (Number.isNaN(cur) || Number.isNaN(prev)) continue
        if (cur > prev) cnt++
      }
      return cnt
    }

    function downCount(ph) {
      if (!ph || ph.length < 2) return 0
      let cnt = 0
      let steps = 0
      for (let i = ph.length - 1; i > 0 && steps < priceCols; i--, steps++) {
        const cur = Number(ph[i].p)
        const prev = Number(ph[i-1].p)
        if (Number.isNaN(cur) || Number.isNaN(prev)) continue
        if (cur < prev) cnt++
      }
      return cnt
    }

    function mixedScore(ph) {
      const s = upStreak(ph)
      const c = upCount(ph)
      return 0.6 * s + 0.4 * c
    }

    function computeTrend(pts) {
      if (!pts || pts.length < trendWindow) return 0
      const slice = pts.slice(pts.length - trendWindow)
      const xs = slice.map((pt) => (pt.ts - slice[0].ts) / 60000)
      const ys = slice.map((pt) => Math.log(Math.max(1e-12, pt.p)))
      let mx = 0, my = 0
      for (let i = 0; i < xs.length; i++) { mx += xs[i]; my += ys[i] }
      mx /= xs.length; my /= ys.length
      let num = 0, den = 0
      for (let i = 0; i < xs.length; i++) { const dx = xs[i] - mx; num += dx * (ys[i] - my); den += dx * dx }
      if (den === 0) return 0
      const slopePerMin = num / den
      return slopePerMin * 100
    }

    function computeTrendFromPct(pcts, intervalMs) {
      if (!pcts || pcts.length < trendWindow) return null
      const slice = pcts.slice(pcts.length - trendWindow).map(Number).filter(v => !Number.isNaN(v))
      if (slice.length < trendWindow) return null
      const stepMin = (intervalMs || 10000) / 60000
      const xs = Array.from({ length: slice.length }, (_, i) => i * stepMin)
      let mx = 0, my = 0
      for (let i = 0; i < xs.length; i++) { mx += xs[i]; my += slice[i] }
      mx /= xs.length; my /= xs.length
      let num = 0, den = 0
      for (let i = 0; i < xs.length; i++) { const dx = xs[i] - mx; num += dx * (slice[i] - my); den += dx * dx }
      if (den === 0) return 0
      const slopePerMin = num / den
      return slopePerMin
    }

    function aggregateMinutePrices(ph, ppm, cols) {
      if (!ph || ph.length === 0) return []
      const res = []
      const need = (ppm || pointsPerMinute) * (cols || priceCols)
      const slice = ph.slice(-need)
      for (let i = slice.length; i > 0 && res.length < (cols || priceCols); i -= (ppm || pointsPerMinute)) {
        const group = slice.slice(Math.max(0, i - (ppm || pointsPerMinute)), i)
        let sum = 0, cnt = 0, ts = null
        for (const it of group) { const n = Number(it.p); if (!Number.isNaN(n)) { sum += n; cnt++; ts = it.ts } }
        if (cnt > 0) res.push({ p: sum / cnt, ts })
        else res.push({ p: null, ts })
      }
      return res
    }

    function notifyNew(symbol) {
      if (alertedNew.has(symbol)) return
      const text = pairWithSlash(symbol)
      console.log("new token", text)
      statusEl.textContent = 'New ' + text + ' copied'
      alertedNew.add(symbol)
      renderNewBar()
      showToast('New token: ' + text + ' copied')
    }

    function renderNewBar() {
      if (!newBarEl) return
      if (alertedNew.size === 0) { newBarEl.textContent = ''; return }
      const items = Array.from(alertedNew)
      const chips = items.map(s => `<span class="chip new">${pairWithSlash(s)}</span>`).join(' ')
      newBarEl.innerHTML = `<span class="new">New tokens:</span> ${chips}`
    }

    function showToast(text) {
      if (!toastRoot) return
      const el = document.createElement('div')
      el.className = 'toast'
      const span = document.createElement('span')
      span.textContent = text
      const btn = document.createElement('button')
      btn.className = 'toast-close'
      btn.textContent = '×'
      btn.addEventListener('click', () => { try { toastRoot.removeChild(el) } catch {} })
      el.appendChild(span)
      el.appendChild(btn)
      toastRoot.appendChild(el)
    }

    function pairWithSlash(symbol) {
      const knownQuotes = ['USDT','USDC','BTC','ETH','MX','BNB']
      for (const q of knownQuotes) {
        if (symbol.endsWith(q)) return symbol.slice(0, -q.length) + '/' + q
      }
      return symbol
    }

    function pairUrl(symbol) {
      const knownQuotes = ['USDT','USDC','BTC','ETH','MX','BNB']
      for (const q of knownQuotes) {
        if (symbol.endsWith(q)) {
          const base = symbol.slice(0, -q.length)
          
          return 'https://www.mexc.com/futures/' + base + '_' + q + '?type=linear_swap'
        }
      }
      return 'https://www.mexc.com/futures/' + symbol + '?type=linear_swap'
    }

    function spotToFutures(symbol) {
      const q = 'USDT'
      if (symbol.endsWith(q)) {
        const base = symbol.slice(0, -q.length)
        return base + '_' + q
      }
      return symbol
    }

    function buildHeaders(sec) {
      const leftLabels = ['No','Pair']
      const modeLabel = orderMode === 'upcount' ? 'Up-count' : (orderMode === 'downcount' ? 'Down-count' : '')
      if (modeLabel) leftLabels.push(modeLabel)
      sec.theadLeft.innerHTML = '<tr>' + leftLabels.map((c,i) => {
        const cls = i===0?'col-no':(i===1?'col-pair':'cell')
        return `<th class="nowrap ${cls}">${c}</th>`
      }).join('') + '</tr>'
      const labels = []
      for (let i = priceCols; i >= 1; i--) labels.push('p' + i)
      sec.theadRight.innerHTML = '<tr>' + labels.map(c => `<th class="nowrap cell">${c}</th>`).join('') + '</tr>'
    }

    function apiFetch(urlStr, opts = {}) {
      const headers = Object.assign({}, opts.headers || {})
      if (authToken) headers['Authorization'] = 'Bearer ' + authToken
      return fetch(urlStr, Object.assign({}, opts, { headers }))
    }

    async function fetchTickersFor(sec) {
      const start = Date.now()
      statusEl.textContent = 'Fetching...'
      try {
        const res = await apiFetch(API)
        const data = await res.json()
        const items = Array.isArray(data) ? data : [data]
        const filtered = items.filter(x => x.symbol && x.symbol.endsWith('USDT') && allowedFutures.has(spotToFutures(x.symbol)))
        filtered.forEach(x => {
          try {
            const symbol = x.symbol
            const lastPrice = x.lastPrice
            const pct = x.priceChangePercent
            const amount = x.volume || x.quoteVolume || ''
            let row = sec.state.get(symbol)
            if (!row) {
              row = { symbol, lastPrice: null, pct: null, amount: null, history: [], priceHistory: [], trend10: 0, prevTrend10: null, trendHistory: [] }
              sec.state.set(symbol, row)
              if (sec.tick >= trendWindow && sec.id === 1) notifyNew(symbol)
              if (!hydratedSymbols.has(symbol)) { hydratedSymbols.add(symbol); hydrateHistory(symbol).catch(()=>{}) }
            }
            const now = Date.now()
            row.priceHistory.push({ p: Number(lastPrice), ts: now })
            if (row.priceHistory.length > maxPriceHistory) row.priceHistory.shift()
            row.lastPrice = lastPrice
            row.pct = pct
            row.amount = amount
            row.history.push(pct)
            if (row.history.length > maxHistory) row.history.shift()
            const prevT = row.trend10
            const intervalMs = sec.intervalMs
            const tNow = computeTrendFromPct(row.history, intervalMs)
            if (tNow != null) {
              row.trend10 = tNow
              row.prevTrend10 = prevT
              if (!row.trendHistory) row.trendHistory = []
              row.trendHistory.push(row.trend10)
              if (row.trendHistory.length > maxTrendHistory) row.trendHistory.shift()
            }
          } catch {}
        })
        sec.tick++
        if (sec.tick % pointsPerMinute === 0) {
          renderSection(sec)
          const ms = Date.now() - start
          statusEl.textContent = 'Updated ' + new Date().toLocaleTimeString() + ' • ' + ms + 'ms'
        } else {
          const done = sec.tick % pointsPerMinute
          statusEl.textContent = 'Collecting ' + done + '/' + pointsPerMinute
        }
      } catch (e) {
        statusEl.textContent = 'Error' + (e && e.message ? (': ' + e.message) : '')
      }
    }

    async function hydrateHistory(symbol) {
      try {
        const res = await apiFetch('/api/history?symbol=' + encodeURIComponent(symbol) + '&limit=' + priceCols)
        const arr = await res.json()
        const secs = sections
        for (const sec of secs) {
          const row = sec.state.get(symbol)
          if (!row) continue
          if (!Array.isArray(arr)) continue
          const mapped = arr.map(x => ({ p: Number(x.p), ts: Number(x.ts) }))
          row.priceHistory = mapped.slice(-maxPriceHistory)
        }
      } catch {}
    }

    function renderSection(sec) {
      buildHeaders(sec)
      const rows = Array.from(sec.state.values())
      rows.sort((a,b) => {
        const al = (a.priceHistory && a.priceHistory.length) ? a.priceHistory.length : 0
        const bl = (b.priceHistory && b.priceHistory.length) ? b.priceHistory.length : 0
        const aNew = (sec.tick >= trendWindow) && (al < trendWindow)
        const bNew = (sec.tick >= trendWindow) && (bl < trendWindow)
        if (aNew && !bNew) return -1
        if (bNew && !aNew) return 1
        const aAgg = aggregateMinutePrices(a.priceHistory, pointsPerMinute, priceCols)
        const bAgg = aggregateMinutePrices(b.priceHistory, pointsPerMinute, priceCols)
        const sa = orderMode === 'mixed' ? mixedScore(aAgg) : (
          orderMode === 'upcount' ? upCount(aAgg) : (
          orderMode === 'downcount' ? downCount(aAgg) : (
          orderMode === 'downstreak' ? downStreak(aAgg) : upStreak(aAgg))))
        const sb = orderMode === 'mixed' ? mixedScore(bAgg) : (
          orderMode === 'upcount' ? upCount(bAgg) : (
          orderMode === 'downcount' ? downCount(bAgg) : (
          orderMode === 'downstreak' ? downStreak(bAgg) : upStreak(bAgg))))
        if (sb !== sa) return sb - sa
        const aLast = (aAgg && aAgg.length) ? Number(aAgg[aAgg.length - 1].p) : NaN
        const bLast = (bAgg && bAgg.length) ? Number(bAgg[bAgg.length - 1].p) : NaN
        if (!Number.isNaN(aLast) && !Number.isNaN(bLast) && bLast !== aLast) return bLast - aLast
        const ap = Number(a.pct || 0)
        const bp = Number(b.pct || 0)
        if (bp !== ap) return bp - ap
        return Number(b.trend10 || 0) - Number(a.trend10 || 0)
      })
      const top = rows.slice(0, 30)
      const leftHtml = top.map((r,i) => {
        const cls = Number(r.pct) >= 0 ? 'pos' : 'neg'
        const pair = pairWithSlash(r.symbol)
        let countCell = ''
        if (orderMode === 'upcount') {
          const agg = aggregateMinutePrices(r.priceHistory, pointsPerMinute, priceCols)
          countCell = `<td class="num cell">${upCount(agg)}</td>`
        } else if (orderMode === 'downcount') {
          const agg = aggregateMinutePrices(r.priceHistory, pointsPerMinute, priceCols)
          countCell = `<td class="num cell">${downCount(agg)}</td>`
        }
        return `<tr class="row" data-symbol="${r.symbol}"><td class="num col-no">${i+1}</td><td class="col-pair copyable" data-pair="${pair}" title="Click to copy">${pair}</td>${countCell}</tr>`
      }).join('')
      const rightHtml = top.map((r,i) => {
        const cls = Number(r.pct) >= 0 ? 'pos' : 'neg'
        const phCells = []
        const agg = aggregateMinutePrices(r.priceHistory, pointsPerMinute, priceCols)
        const len = agg.length
        for (let j = 1; j <= priceCols; j++) {
          const idx = len - j
          const v = idx >= 0 ? agg[idx] : null
          const prev = (idx - 1 >= 0) ? agg[idx - 1] : null
          let c = 'muted'
          let text = ''
          let arrowHtml = ''
          if (v && typeof v.p !== 'undefined') {
            const cur = Number(v.p)
            const pn = prev && typeof prev.p !== 'undefined' ? Number(prev.p) : null
            if (!Number.isNaN(cur)) {
              if (pn != null && !Number.isNaN(pn)) {
                if (cur > pn) arrowHtml = '<span class="arrow-up">↑</span>'
                else if (cur < pn) arrowHtml = '<span class="arrow-down">↓</span>'
                else arrowHtml = '<span class="arrow-flat">→</span>'
                c = cur >= pn ? (cur === pn ? 'muted' : 'pos') : 'neg'
              } else {
                c = 'muted'
              }
              text = `${arrowHtml} ${fmtNum(cur)}`
            }
          }
          phCells.push(`<td class="cell ${c}">${text}</td>`)
        }
        return `<tr class="row" data-symbol="${r.symbol}">${phCells.join('')}</tr>`
      }).join('')
      sec.tbodyLeft.innerHTML = leftHtml
      sec.tbodyRight.innerHTML = rightHtml
      if (selectedSymbol) setActive(selectedSymbol)
    }

    function aTickStart() { return Math.max(0, tick - (maxHistory - 1)) }
    function histCols(chips) {
      if (!chips || chips.length === 0) return ''
      return chips.map(p => `<td class="cell">${p}</td>`).join('')
    }

    function startPollingSections() {
      sections.forEach(sec => {
        if (sec.timer) clearInterval(sec.timer)
        fetchTickersFor(sec)
        sec.timer = setInterval(() => fetchTickersFor(sec), sec.intervalMs)
      })
    }

    function startWebSocket() {
      try {
        const ws = new WebSocket(WS_PATH)
        ws.onopen = () => { statusEl.textContent = 'Streaming' }
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data)
            if (msg.type === 'miniTickers') {
              const data = msg.data
              const items = Array.isArray(data) ? data : [data]
              const filtered = items.filter(x => x.symbol && x.symbol.endsWith('USDT') && allowedFutures.has(spotToFutures(x.symbol)))
              filtered.forEach(x => {
                const symbol = x.symbol
                const lastPrice = x.price
                const pct = (x.zonedRate ?? x.rate)
                const amount = x.quantity || x.volume || ''
                let row = state.get(symbol)
          if (!row) {
            row = { symbol, lastPrice: null, pct: null, amount: null, history: [], priceHistory: [], trend10: 0, prevTrend10: null, trendHistory: [] }
            state.set(symbol, row)
            if (tick >= trendWindow) notifyNew(symbol)
          }
          const now = Date.now()
          row.priceHistory.push({ p: Number(lastPrice), ts: now })
          if (row.priceHistory.length > maxPriceHistory) row.priceHistory.shift()
          row.lastPrice = lastPrice
          row.pct = pct
          row.amount = amount
          row.history.push(pct)
          if (row.history.length > maxHistory) row.history.shift()
          const prevT = row.trend10
          const intervalMs = 30000
          const tNow = computeTrendFromPct(row.history, intervalMs)
          if (tNow != null) {
            row.trend10 = tNow
            row.prevTrend10 = prevT
            row.trendHistory.push(row.trend10)
            if (row.trendHistory.length > maxTrendHistory) row.trendHistory.shift()
          }
              })
              tick++
              render()
            }
          } catch {}
        }
        ws.onclose = () => { statusEl.textContent = 'Disconnected'; startPolling() }
        ws.onerror = () => { statusEl.textContent = 'WS Error'; startPolling() }
      } catch {
        startPolling()
      }
    }

    function setActive(symbol) {
      selectedSymbol = symbol
      document.querySelectorAll('tr.row.selected').forEach(el => el.classList.remove('selected'))
      document.querySelectorAll(`tr.row[data-symbol="${symbol}"]`).forEach(el => el.classList.add('selected'))
    }

    function onRowClick(e) {
      const tr = e.target.closest('tr.row')
      if (!tr) return
      const symbol = tr.getAttribute('data-symbol')
      if (!symbol) return
      setActive(symbol)
      const text = pairUrl(symbol)
      if (e.ctrlKey) {
        try { window.open(text, '_blank') } catch {}
        statusEl.textContent = 'Opened ' + text
        return
      }
      try {
        navigator.clipboard && navigator.clipboard.writeText(text)
        statusEl.textContent = 'Copied ' + text
      } catch {}
    }

    function onRowDblClick(e) {
      const tr = e.target.closest('tr.row')
      if (!tr) return
      const symbol = tr.getAttribute('data-symbol')
      if (!symbol) return
      setActive(symbol)
      const text = pairUrl(symbol)
      try { navigator.clipboard && navigator.clipboard.writeText(text) } catch {}
      try { window.open(text, '_blank') } catch {}
      statusEl.textContent = 'Copied and opened ' + text
    }

    sections.forEach(sec => {
      sec.tbodyLeft.addEventListener('click', onRowClick)
      sec.tbodyRight.addEventListener('click', onRowClick)
      sec.tbodyLeft.addEventListener('dblclick', onRowDblClick)
      sec.tbodyRight.addEventListener('dblclick', onRowDblClick)
    })

    orderSwitch.addEventListener('click', (e) => {
      const btn = e.target.closest('.seg-option')
      if (!btn) return
      orderMode = btn.dataset.mode
      orderSwitch.querySelectorAll('.seg-option').forEach(b => b.classList.toggle('active', b === btn))
      sections.forEach(renderSection)
    })

    async function loadFuturesAllowed() {
      try {
        const res = await apiFetch('/api/futures/contracts?settle=USDT')
        const data = await res.json()
        const list = Array.isArray(data.symbols) ? data.symbols : []
        list.forEach(s => allowedFutures.add(s))
        futuresReady = true
      } catch {}
    }

    async function initialize() {
      await loadFuturesAllowed()
      startPollingSections()
    }

    async function tryLogin(password) {
      loginError.style.display = 'none'
      try {
        const res = await fetch('/api/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ password }) })
        if (!res.ok) { loginError.style.display = 'block'; return }
        const data = await res.json()
        const token = data && data.token
        if (token) {
          authToken = token
          try { localStorage.setItem('authToken', token) } catch {}
          lockScreen.style.display = 'none'
          initialize()
        } else {
          loginError.style.display = 'block'
        }
      } catch {
        loginError.style.display = 'block'
      }
    }

    unlockBtn.addEventListener('click', () => { const pw = pwdInput.value || ''; tryLogin(pw) })
    pwdInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { const pw = pwdInput.value || ''; tryLogin(pw) } })

    if (authToken) { lockScreen.style.display = 'none'; initialize() } else { lockScreen.style.display = 'flex' }
  </script>
</body>
</html>
